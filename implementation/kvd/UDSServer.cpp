/**
 *
 * @author <va.yastrebov>
 * @description
 * <pre>
 *    Class is responsible for processing incoming connections from clients
  * </pre>
 *
 * @class UDSServer
 */

#include"UDSServer.h"

/**
 * CTOR
 */
UDSServer::UDSServer( asio::io_service& io_service, const std::string& s_sock_fname ) :
   asioService( io_service ),
   asioAcceptor( io_service, stream_protocol::endpoint( s_sock_fname ) ),
   nMaxOnlineUsers( 1 ),
   numOnlineUsers( 0 )
{
   pDataBase = std::make_shared<DataBase>();

   std::shared_ptr<Session> p_new_session =
      std::make_shared<Session>( asioService, pDataBase );
   StartToListenForNewSession( p_new_session );
}

/**
 * DTOR
 */
UDSServer::~UDSServer()
{
   std::cout << "UDSServer DTOR" << std::endl;
}

/**
 * Create and intialize new session for communication with
 * client socket
 */
void UDSServer::StartToListenForNewSession(
   std::shared_ptr<Session> &p_new_session )
{
   SubscribeToEvents( p_new_session );

   asioAcceptor.async_accept(
      p_new_session->getSocket(),
      std::bind(
         &UDSServer::HandleAccept, this,
         p_new_session, std::placeholders::_1
      )
   );
}

/**
 * Subscribe to events generated by session
 */
void UDSServer::SubscribeToEvents( std::shared_ptr<Session> &s )
{
   s->sessionIsOverEvent =
      std::bind( &UDSServer::OnSessionIsOver, this );

   s->stopServerEvent =
      std::bind( &UDSServer::OnStopServer, this );
}

/**
 * Accept new connection handler
 */
void UDSServer::HandleAccept( std::shared_ptr<Session> p_new_session, const asio::error_code& error )
{
   std::cout << "HandleAccept() fired" << std::endl; 
   if( error )
   {
      std::cout << "HandleAccept() error occured: " 
         << error << std::endl;
   }
   else
   {
      numOnlineUsers.fetch_add( 1 );
      p_new_session->Start();
   }

   std::cout << "numOnlineUsers: " << numOnlineUsers.load() << std::endl; 
   if( numOnlineUsers.load() < nMaxOnlineUsers )
   {
      std::cout << "Start new session" << std::endl; 

      p_new_session.reset( new Session( asioService, pDataBase ));
      StartToListenForNewSession( p_new_session );
   }

}

/**
 * Process session is over event
 */
void UDSServer::OnSessionIsOver()
{
   numOnlineUsers.fetch_sub( 1 );
   std::cout << "Num online users: " <<
      numOnlineUsers.load() << std::endl;

   if( numOnlineUsers.load() < nMaxOnlineUsers )
   {
      std::shared_ptr<Session> p_session =
         std::make_shared<Session>( asioService, pDataBase );
      StartToListenForNewSession( p_session );
   }
}

/**
 * Process session is over event
 */
void UDSServer::OnStopServer()
{
   std::cout << "Receive stop server command" << std::endl;
   asioService.stop();

   // while( numOnlineUsers.load() != 0 )
   // {
   //    std::this_thread::yield();
   // }
}
